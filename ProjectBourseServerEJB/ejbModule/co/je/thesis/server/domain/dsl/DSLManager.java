package co.je.thesis.server.domain.dsl;

import java.util.ArrayList;

import co.je.thesis.common.domainObjects.ValidRule;
import co.je.thesis.common.dtos.analysis.AnalysisDTO;
import co.je.thesis.common.dtos.dsl.DSLDataTransferObject;
import co.je.thesis.common.dtos.rules.RuleDTO;
import co.je.thesis.server.domain.dsl.commands.ICommand;
import co.je.thesis.server.persistence.dsl.DSLPersistence;
import co.je.thesis.server.persistence.rules.RulePersistence;

/**
 * This class encapsulates the logic necessary in order to support the functionalities related
 * with the system's DSL.
 * 
 * @author Julian Espinel
 */
public class DSLManager {

	/**
	 * This attribute know how to handle the DSL persistence.
	 */
	private DSLPersistence dslPersistence;
	
	/**
	 * This attribute know how to handle the rules persistence.
	 */
	private RulePersistence rulesPersistence;

	/**
	 * DSLManager constructor.
	 */
	public DSLManager() {

		dslPersistence = new DSLPersistence();
		rulesPersistence = new RulePersistence();
	}

	// DSL

	/**
	 * Determines if a given DSL version is the current version or not.
	 * 
	 * @param clientDSLVersion the given DSL version, or the version of the DSL that a client has.
	 * @return if the given DSL version is the current version, then returns true, 
	 * 		   else returns false.
	 */
	public boolean isDSLUpToDate(int clientDSLVersion) {

		int dslVersion = dslPersistence.getDSLVersion();
		boolean answer = (dslVersion == clientDSLVersion);

		return answer;
	}

	/**
	 * Returns the current DSL version.
	 * 
	 * @return the current DSL version.
	 */
	public int getDSLVersion() {

		int dslVersion = dslPersistence.getDSLVersion();
		return dslVersion;
	}

	/**
	 * Returns the whole DSL.
	 * 
	 * @return the whole DSL.
	 */
	public DSLDataTransferObject getDSL() {

		DSLDataTransferObject dsl = dslPersistence.getDSL();
		return dsl;
	}

	// Valid Rules (DSL's Grammar)

	/**
	 * Determines if a given valid rules version is the current or not.
	 * 
	 * @param clientValidRulesVersion the version of the valid rules that a client has.
	 * @return if the given valid rules version is the current one, then returns true, 
	 * 		   else returns false.
	 */
	public boolean areRulesUpToDate(int clientValidRulesVersion) {

		int validRulesVersion = rulesPersistence.getValidRulesVersion();
		boolean answer = (validRulesVersion == clientValidRulesVersion);

		return answer;
	}

	/**
	 * Returns the current valid rules version.
	 * 
	 * @return the current valid rules version.
	 */
	public int getValidRulesVersion() {

		int validRulesVersion = rulesPersistence.getValidRulesVersion();
		return validRulesVersion;
	}

	/**
	 * Returns an ArrayList that contains the DSL's valid rules.
	 * 
	 * @return an ArrayList that contains the DSL's valid rules.
	 */
	public ArrayList<ValidRule> getValidRules() {

		ArrayList<ValidRule> validRules = rulesPersistence.getValidRules();
		return validRules;
	}

	// Analysis services

	/**
	 * Verifies that the structure of a given analysis is correct.
	 * 
	 * @param analysisDTO the analysis to verify.
	 */
	public void verifyAnalysis(AnalysisDTO analysisDTO) {

		ArrayList<ValidRule> validRules = getValidRules();
		DSLVerifier dslVerifier = new DSLVerifier(validRules);
		dslVerifier.verifyAnalysis(analysisDTO);
	}
	
	/**
	 * Returns the command generated by the DSL elements before the conditional operator
	 * of the rule.
	 * 
	 * @param ruleDTO the rule to be interpreted.
	 * @return the command generated by the DSL elements before the conditional operator
	 * 		   of the rule.
	 */
	public ICommand getCommandBeforeConditionalOperator(RuleDTO ruleDTO) {
		
		DSLInterpreter dslInterpreter = new DSLInterpreter();
		ICommand commandBeforeCo = dslInterpreter.getCommandBeforeConditionalOperator(ruleDTO);
		
		return commandBeforeCo;
	}
	
	/**
	 * Returns the conditional operator from the rule.
	 * 
	 * @param ruleDTO the rule to be interpreted.
	 * @return the conditional operator from the rule.
	 */
	public ICommand getConditionalOperator(RuleDTO ruleDTO) {
		
		DSLInterpreter dslInterpreter = new DSLInterpreter();
		ICommand conditionalOperatorCommand = dslInterpreter.getConditionalOperatorCommand(ruleDTO);
		
		return conditionalOperatorCommand;
	}
	
	/**
	 * Returns the command generated by the DSL elements after the conditional operator
	 * of the rule.
	 * 
	 * @param ruleDTO the rule to be interpreted.
	 * @return the command generated by the DSL elements after the conditional operator
	 * 		   of the rule.
	 */
	public ICommand getCommandAfterConditionalOperator(RuleDTO ruleDTO) {
		
		DSLInterpreter dslInterpreter = new DSLInterpreter();
		ICommand commandAfterCo = dslInterpreter.getCommandAfterConditionalOperator(ruleDTO);
		
		return commandAfterCo;
	}
}